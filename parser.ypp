
%{
    #include <iostream>
    using namespace std;
    int yylex();
    void yyerror(const char*);
    #include "hw3_output.hpp"
    #include "output.hpp"
    extern int yylineno;
    using namespace output;
    int loopDepth = 0;
    #include "source.hpp"
    #include "CheckFunctions.h"
    TablesStack* tableStack=new TablesStack;
    offsetStack* offsettStack=new offsetStack;
%}



%token INT BYTE B BOOL  TRUE FALSE RETURN IF  WHILE BREAK CONTINUE SC LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left  equality
%left  relational
%left  additive
%left  multiplicative
%right NOT
%left LPAREN
%left RPAREN
%right ELSE
%token COMMA


%%




Program: M1 Statements {checkMainFunction(*tableStack);exitScope(*tableStack);};

M1: {     vector<string> printParmType={"string"};
        addFunctionToGlobalScope(*tableStack,"print","void",printParmType);
          vector<string> printiParmType={"int"};
        addFunctionToGlobalScope(*tableStack,"printi","void",printiParmType);
          vector<string> readiParmType={"int"};
        addFunctionToGlobalScope(*tableStack,"readi","int",readiParmType);
        };


Statements: Statement{printProductionRule(2);}
            | Statements Statement {printProductionRule(3);};



Statement: LBRACE Statements RBRACE {printProductionRule(4);}
            | Type ID SC {checkVariableDeclaration(*tableStack,static_cast<IdentifierStr*>($2)->id,yylineno);
                          addSymbolToCurrentScope(*tableStack,static_cast<IdentifierStr*>($2)->id,static_cast<TNode*>($1)->type,offsettStack->top_offset(yylineno));
                          offsettStack->update_top_offset();
                          delete static_cast<IdentifierStr*>($2);
                          delete static_cast<TNode*>($1);
                          }   /////////////////////////
            | Type ID ASSIGN Exp SC{checkVariableDeclaration(*tableStack,static_cast<IdentifierStr*>($2)->id,yylineno);
                                    checkAssignment(static_cast<TNode*>($1)->type, static_cast<TNode*>($4)->type, yylineno);
                                    addSymbolToCurrentScope(*tableStack,static_cast<IdentifierStr*>($2)->id,static_cast<TNode*>($1)->type,offsettStack->top_offset(yylineno));
                                    offsettStack->update_top_offset();
                                    delete static_cast<IdentifierStr*>($2);
                                    delete static_cast<TNode*>($1);
                                    delete static_cast<TNode*>($4);
                                     } /////////////////////////////
            | ID ASSIGN Exp SC{printProductionRule(7);}
            | Call SC{printProductionRule(8);}
            | RETURN SC{printProductionRule(9);}
            | IF LPAREN Exp RPAREN Statement{printProductionRule(10);}
            | IF LPAREN Exp RPAREN Statement ELSE Statement{printProductionRule(11);}
            | WHILE LPAREN Exp RPAREN Statement{printProductionRule(12);}
            | BREAK SC{printProductionRule(13);}
            | CONTINUE SC {printProductionRule(14);};



Call: ID LPAREN Exp RPAREN{printProductionRule(15);};



Type: INT { $$=new TNode("int");}
    | BYTE { $$=new TNode("byte");}
    | BOOL { $$=new TNode("bool");};



Exp: LPAREN Exp RPAREN{printProductionRule(19);}
    |Exp additive Exp{printProductionRule(20);}
    |Exp multiplicative Exp{printProductionRule(20);}
    |ID{printProductionRule(21);}
    |Call{printProductionRule(22);}
    |NUM{printProductionRule(23);}
    |NUM B{printProductionRule(24);}
    |STRING{printProductionRule(25);}
    |TRUE{printProductionRule(26);}
    |FALSE{printProductionRule(27);}
    |NOT Exp{printProductionRule(28);}
    |Exp AND Exp{printProductionRule(29);}
    |Exp OR Exp{printProductionRule(30);}
    |Exp equality Exp{printProductionRule(31);}
    |Exp relational Exp{printProductionRule(31);}
    |LPAREN Type RPAREN Exp{printProductionRule(32);};



%%
int main(){
    return yyparse();
}

void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}