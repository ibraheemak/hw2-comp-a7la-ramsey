%{
#include "parser.hpp"
#include "auxFunctions.h"
#include <iostream>
#include <stdlib.h>

using namespace std;

extern int yylex();
int yyerror(const char * message);

%}

%union{
    int num;
    char* id;
    char* str;
}

%token INT BYTE B BOOL
%token TRUE FALSE
%token RETURN IF ELSE
%token WHILE BREAK CONTINUE
%token SC COMMA
%token LPAREN RPAREN LBRACE RBRACE
%token ASSIGN
%token RELOP BINOP
%token AND OR NOT
%token <id> ID
%token <num> NUM
%token <str> STRING

%right ASSIGN
%left OR
%left AND
%nonassoc RELOP
%left BINOP
%right NOT
%left LPAREN RPAREN
%right ELSE

%type <str> Type
%type <str> Exp
%type <str> Call

%%

Program : Statements                    { exit_scope(); }
        ;

Statements : Statement
           | Statements Statement
           ;

Statement : LBRACE NewScope Statements RBRACE    { exit_scope(); }
          | Type ID SC                           { add_variable($2, $1, yylineno); }
          | Type ID ASSIGN Exp SC                {
                add_variable($2, $1, yylineno);
                check_valid_assignment($1, $4, yylineno);
            }
          | ID ASSIGN Exp SC                     {
                const char* type = get_variable_type($1, yylineno);
                check_valid_assignment(type, $3, yylineno);
            }
          | Call SC
          | RETURN SC
          | IF LPAREN Exp RPAREN NewScope Statement
          | IF LPAREN Exp RPAREN NewScope Statement ELSE NewScope Statement
          | WHILE LPAREN Exp RPAREN { enter_while_loop(); } NewScope Statement   { exit_while_loop(); }
          | BREAK SC                             { check_while_scope(yylineno); }
          | CONTINUE SC                          { check_while_scope(yylineno); }
        ;

Call : ID LPAREN Exp RPAREN                      {
            check_defined_function($1, yylineno);
            const char* returnType = get_function_return_type($1, yylineno);
            std::vector<std::string> params = symbolTable.getFunctionParams($1);
            if (!params.empty()) {
                check_valid_assignment(params[0].c_str(), $3, yylineno);
            }
            $$ = strdup(returnType);
        }
    ;

Type : INT   { $$ = strdup("INT"); }
     | BYTE  { $$ = strdup("BYTE"); }
     | BOOL  { $$ = strdup("BOOL"); }
     ;

Exp : LPAREN Exp RPAREN                  { $$ = $2; }
    | Exp BINOP Exp                      {
        check_numeric_type($1, yylineno);
        check_numeric_type($3, yylineno);
        $$ = strdup(get_larger_type($1, $3));
    }
    | ID                                 { $$ = strdup(get_variable_type($1, yylineno)); }
    | Call                               { $$ = $1; }
    | NUM                                { $$ = strdup("INT"); }
    | NUM B                              {
        check_byte_range($1, yylineno);
        $$ = strdup("BYTE");
    }
    | STRING                             { $$ = strdup("STRING"); }
    | TRUE                               { $$ = strdup("BOOL"); }
    | FALSE                              { $$ = strdup("BOOL"); }
    | NOT Exp                            {
        check_bool_type($2, yylineno);
        $$ = strdup("BOOL");
    }
    | Exp AND Exp                        {
        check_bool_type($1, yylineno);
        check_bool_type($3, yylineno);
        $$ = strdup("BOOL");
    }
    | Exp OR Exp                         {
        check_bool_type($1, yylineno);
        check_bool_type($3, yylineno);
        $$ = strdup("BOOL");
    }
    | Exp RELOP Exp                      {
        check_numeric_type($1, yylineno);
        check_numeric_type($3, yylineno);
        $$ = strdup("BOOL");
    }
    | LPAREN Type RPAREN Exp             {
        check_valid_assignment($2, $4, yylineno);
        $$ = strdup($2);
    }
    ;

NewScope : %empty { enter_scope(); }
         ;

%%

int main()
{
    return yyparse();
}

int yyerror(const char * message)
{
    output::errorSyn(yylineno);
    exit(0);
}